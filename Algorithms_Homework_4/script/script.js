// Algorithms_Homework_4

// 1) Вопрос: Какие три операции лежат в основе алгоритма разделяй и властвуй?
//    Ответ: 
// 1.1) Divide: включает в себя разделение проблемы на более мелкие подзадачи.
// 1.2) Conquer: рекурсивно вызываем подзадачи до тех пор, пока они не будут решены.
// 1.3) Сombine: обьеденить подзадачи, чтобы получить окончательное решение всей проблемы.


// 2) Вопрос: В чем преимущества и недостатки алгоритма разделяй и властвуй?
//    Ответ: 
// 1.1) Приемущества: Сложная проблема решается легко, делит задачу на подзадачи, эффективно использует кэш-память, снижает временную сложность задачи.
// 1.2) Недостатки:  включает в решение рекурсию, которая зачастую медлительна, эффективность зависит от реализации логики. Если в рекурсии есть ошибки, это может привести к сбою системы. 


// 3) Вопрос: Опишите алгоритм бинарного поиска словами или псевдокодом
//    Ответ: 
// 3.1) Выбираем середину массива(записываем в переменную);
// 3.2) Cравниваем значение в середине массива с искомым значением;
// 3.3) Если значение в середине массива меньше, чем искомое значение, то ищем в правой части массива. Если же больше, то в левой;
// 3.4) Возврат индекса найденного элемента, либо -1, если элемент не найден.


// 4) Вопрос: Какова сложность бинарного поиска?
//    Ответ: O(n log(n))

// 5) Вопрос: Попробуйте написать алгоритм бинарного поиска
//    Ответ: 

// const binarySearch = (number, array, from, to) => {
//     if (to <= from) {
//         return number === array[from] ? from : -1;
//     };
//     const middle = Math.floor((from + to) / 2);

//     return array[middle] < number
//         ? binarySearch(number, array, middle + 1, to)
//         : binarySearch(number, array, from, middle);
// };

// 6) Решение сделано рекурсивным подходом.

//  const calculate = (x, n) => {
//     if (n === 0) {
//         return 1;
//       };
//       return x * calculate (x, n - 1);
//  };

// 7) Был использован способ через соеденение двух массивов в один.

// const findElem = (arr1, arr2, k) => {
//     const mergedArr = mergeArr(arr1, arr2);
//     return mergedArr[k - 1];
// }

// const mergeArr = (arr1, arr2) => {
//     const merged = [];
//     let i = 0;
//     let j = 0;

//     for (; i < arr1.length && j < arr2.length;) {
//         if (arr1[i] <= arr2[j]) {
//             merged.push(arr1[i++]);
//         } else {
//             merged.push(arr2[j++]);
//         }
//     };

//     for (; i < arr1.length;) {
//         merged.push(arr1[i++]);
//     };

//     for (; j < arr2.length;) {
//         merged.push(arr2[j++]);
//     };
//     return merged
// };